# weatherapp

This project is live at: https://salty-scrubland-70759.herokuapp.com/

The project requirement was to use the OpenWeatherMap API and in order to safeguard keys a back end should be used. In this case I used an express app with node-fetch in order to make requests to the weather API. There are two endpoints, current and 5day. Each fetches data and returns it to the client. Some error handling is implemented.

As for the front end of the project, React was used due to the roles available utilizing the framework. A service was implemented using the simple browser fetch API. This service is called in order to fetch the weather data from the back end. Together, the service and the back end respond to input with either user geolocation coordinates or a user defined city name query.

In the React app state is handled using hooks at the root level of the app. The App component is responsible for calling the weather service via an Effect hook. This state data is then passed down to the component tree. I like to have components whose sole job is to get data and distribute it and componenets whose sole job is to display data. Separating these concerns makes the data flow easy to manage and visualize.

The app is quite small. When doing a project like this I almost always implement state storage with simple hooks. At scale, this is not a good solution! I acknowledge that. When the component tree gets deeper than threeish levels, then I feel context API becomes a good solution without adding too much bloat. The state data here is largely single featured, meaning all components are concerned with the same piece of state. This means it can simply be handled in a single component near the top of the component tree without too much clutter. I find Redux to become an attractive solution when state data is representing multiple features worth of data. This app doesn't present those challenges, so Redux seems to be a bad fit for this project.

I've implemented some unit tests with Jest on components that are critical to feature functionality. In this case the components rendering the weather data got the testing attention. Jest is included in create-react-app, which I used here for the sake of startup time. I also used Cypress in order to cover testing of the backend and for ensuring core app functionality on the front end. This is a great solution as since state is coupled with the App component, unit testing and to an extent integration testing are more clumsy solutions. Unit testing and integration testing would shine more if state was managed with context, Redux, or some other solution that separates data concerns from a core component. I didn't spend the time to extract a controller or service in the backend, so unit testing on the back end wasn't an easy option without that. Cypress allowed me to at least have some implicit test coverage on the backend.

My design doesn't scale well if you were to add more features. The main state component (App) would get crowded very quickly. When starting from scratch on a project I like to 'get one slice working'. This means that I like to stretch as far to the back end as I can go, and like wise to the front end, and work to connect the flow of data. It feels good to have some functionality up and running fast. Then I build out horizontally from there. For example, I first set up a endpoint for current weather data then displayed that on the front end. Then I added the 5day page and endpoint. Then I added geolocation functionality... slowly expanding the breadth of the app to meet requirements. Working like this is fun and progress is fast paced.

To make this project scalable I'll address a scenario. Let's say I'm trying to add more functionality from the weather API. It could be maps, pollution data, etc. At that point I would definitely implement a more hands on state management approach, allowing state to be decoupled even more from the visualization functionality of the component tree. Isolating the state logic would also open it up to more unit testing coverage.

Overall I had fun doing this project. I always used axios before but the browser fetch API works just fine for projects like this. I also implemented a sort of input debounce using a setTimeout and effect hook. That was neat. I will update this readme with the live url after I deploy the project and submit via email.

The biggest bug I left in is related to single page apps. If a user tries to refresh the page on a route or go there directly, they'll have a Cannot Get ${URL} error. This is because the user hasn't gotten the JavaScript to download from the / route. So they have nothing to render. I know there are ways to fix this (handling it server side or with some webpack config stuff) but for the sake of time I wanted to just submit the project. So if you're visiting this project's website just go to the root domain!

To test:
- from weatherapp/client run 'npm test'
- or have both client and server running and from weatherapp/client run 'npm run cypress:open'
